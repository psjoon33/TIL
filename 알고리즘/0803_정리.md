# 0803_정리

### 알고리즘

- 무엇이 좋은 알고리즘인가?

  - 정확성 : 얼마나 정확한가
  - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
  - 단순성 : 얼마나 단순한가
  - 최적성 : 더 이상 개선할 여지없이 최적화 되었는가

  

- 알고리즘의 작업량을 표현할 때 시간 복잡도로 표현한다.
- 시간 복잡도 : 실제 걸리는 시간을 측정
  - 실행되는 명령문의 갯수를 계산
  - ![image-20200805200520204](0803_%EC%A0%95%EB%A6%AC.assets/image-20200805200520204.png)

- 빅-오 표기법
  - 시간 복잡도는 보통 빅-오 표기법으로 나타낸다.
  - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n 에 대한 항만을 이용
  - ![image-20200805200733388](0803_%EC%A0%95%EB%A6%AC.assets/image-20200805200733388.png)



### 배열

- 일정한 자료형의 변수들을 하나의 이름으로 열거해 사용하는 자료구조
- ![image-20200805200848992](0803_%EC%A0%95%EB%A6%AC.assets/image-20200805200848992.png)

- 배열을 이용함으로써 여러개의 변수가 필요할 때 효율적으로 처리 가능



### 완전 검색

- 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.

- 모든 경우의 수를 테스트하고, 최종 해법을 도출한다.

- 일반적으로 경우의 수가 작을 때 유용하다!

  (모든 경우의 수를 테스트함으로, 경우의 수가 크면 문제 발생할 수 있다.)



- 순열을 생성하는 방법

  ex) {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수

  ```python
  for a in range(1, 4):
      for b in range(1, 4):
          for c in range(1, 4):
              if a != b and a != c and b != c:
                  print([a, b, c])
                  
  #--> 
  [1, 2, 3]
  [1, 3, 2]
  [2, 1, 3]
  [2, 3, 1]
  [3, 1, 2]
  [3, 2, 1]                
  ```

  

- 탐욕 알고리즘(Greedy Algorithm)
  - 탐욕 알고리즘은 최적해를 구하는데 사용되는 근시안적인 방법
  - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하며 최종적인 해답에 도달.
  - 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy한 접근이다.

- 탐욕 알고리즘의 동작 과정
  - 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해집합(solution set)에 추가한다.
  - 실행 가능성 검사 : 새로운 부분해집합이 실행가능한지, 문제없는지 조사.
  - 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지 확인.

ex) 탐욕 알고리즘의 구현 예시

```python
num = 112233
c = [0] * 12

for i in range(6):
    c[num % 10] += 1
    num //= 10

i = 0
tri = run = 0

while i < 10:
    if c[i] >= 3:
        c[i] -= 3
        continue
    if c[i] >= 1 and c[i + 1] >= 1 and c[i + 2] >= 1:
        c[i] -= 1
        c[i + 1] -= 1
        c[i + 2] -= 1
        if c == [0]*12:
            break
        continue
    i += 1

if c == [0] * 12:
    print("babygin")
else:
    print("lose")

    
#break 와 continue의 차이
#break : 그 즉시, 제일 먼저 만나는(제일 가까이 있는) for나 while문을 끝내버림
#continue : 그 즉시, 제일 먼저 만나는(제일 가까이 있는) for나 while문으로 돌아가버림
```



### 정렬

- 2개 이상의 자료를 특정 기준에 의해 오름차순 혹은 내림차순으로 재배열 하는 것!

- 버블 정렬 / 카운팅 정렬 / 선택 정렬 / 삽입 정렬 ...



### 버블 정렬(Bubble Sort)

- 인접한 두 개의 원소를 비교하여 자리를 계속 교환하는 방식

- 정렬 과정

  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
  - 교환하며 자리를 이동하는 모습이 거품 같다고 하여 버블 정렬이라고 한다.

- 시간 복잡도 : O(n**2)

  ​	

### 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 제한사항
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 가능
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내 가장 큰 정수를 미리 알아야 한다.
- 시간 복잡도 : O(n+k)





















