# 0826_정리

## 스택

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조이다.
- 스택에 저장된 자료는 선형 구조를 갖는다.
  - 선형구조 : 자료 간의 관계가 1대 1의 관계를 가진다.
  - 비선형 구조 : 자료 간의 관계가 1대 N의 관계를 갖는다.(ex : 트리)
- 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
- 마지막에 삽입한 자료를 가장 먼저 꺼낸다. == 후입선출



### 스택을 프로그램에서 구현하기 위해 필요한 **자료구조**와 **연산**

- 자료 구조

  : 자료를 선형으로 저장할 저장소

  - 저장소 자체를 스택이라 부르기도 한다.
  - 스택에서 마지막에 삽입된 원소의 위치를 top이라고 한다.

- 연산

  - 삽입 : 저장소에 자료를 저장한다. ==push

  - 삭제 : 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 pop이라고 부른다.

    (pop을 할 때는 항상 isEmpty인지 아닌지를 주의해야 한다.)

  - 스택이 공백인지 아닌지를 확인하는 연산. == isEmpty

  - 스택의 top에 있는 item(원소)을 반환하는 연산 == peek



----

### Memorization

: 메모리 제이션은 컴퓨터 프로그램을 실행할 때 , 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여, 전체적인 실행속도를 빠르게 하는 기술이다. 



**피보나치 수열에서의 memorization**

: 우리가 기존에 재귀를 이용해서 피보나치 수열을 접근하면 매 번 값을 구할 때 마다 복잡한 연사을 반복해야 한다. 하지만, memorization 을 이용하면 실행시간을 훨씬 단축시킬 수 있다.

- 그냥 재귀만 사용해서 하는 피보나치

```python
def fibo(n):
    if n ==0 or n == 1:
        result = 1
    else: 
        result = fibo(n-1) + fibo(n-2)
    return result
```

- Memorization을 이용한 피보나치

```python
def fibo(n):
    global memo
    if n>= 2 and len(memo) = n:
        res = memo[n-2] + memo[n-1]
        memo.append(res)
    return(memo[n])

memo = [1, 1]
```

여기서 작은 n에 대해서는 둘 다 값을 내지만,,,

jupyter notebook에서 두 코드에 대해 fibo(50)을 구하려고 했을 때, 아래의 memorization 을 이용한 방법만 코드가 실행된다는 것을 알 수 있다.

즉, memorization을 이용함으로써 훨씬 실행시간을 단축시킬 수 있다.



하지만, 이보다도 좋은 방법이 있는데 그게 바로 

DP(Dynamic Programming)이다.

----

### DP(Dynamic Programming)

: 동적 계획 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.

: 동적 계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.

- 피보나치 에서의 DP 적용

```python
def fibo(n):
    f = [0, 1]
    for i in range(2, n+1):
        f.append(f[i-1] + f[i-2])
    return f[n]
```



---

# DFS (깊이 우선 탐색) -- 중요!!

- 비선형 구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다.
- 두가지 방법
  - 깊이 우선 탐색(Depth First Search, DFS)
  - 너비 우선 탐색(Breadth First Search, BFS)
- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳 까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회 방법

- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복한다.

  그래서 후입선출 구조의 **스택**을 사용한다.