# 0902_정리

### Queue

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
  - 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조



- 앞에서 한 것들과는 다르게, **선입선출구조(FIFO : First In First Out)**

  - 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.

  

### 큐의 사용을 위해 필요한 주요 연산

1. enqueue(item) : 큐의 뒤쪽에 원소를 삽입하는 연산
2. dequeue : 큐의 앞쪽에서 원소를 삭제하고 반환하는 연산
3. createQueue : 공백 상태의 큐를 생성하는 연산
4. isEmpty : 큐가 공백상태인지를 확인하는 연산
5. isFull : 큐가 포화상태인지를 확인하는 연산
6. Qpeek : 큐의 앞쪽에서 원소를 삭제없이 반환하는 연산



- 머리(Front) : 저장된 원소 중 첫 번째 원소
- 꼬리(Rear) : 저장된 원소 중 마지막 원소



### 선형큐

- 1차원 배열을 이용한 큐
  - 큐의 크기 = 배열의 크기
  - front : 저장된 첫 번째 원소의 인덱스
  - rear : 저장된 마지막 원소의 인덱스
- 상태 표현
  - 초기 상태  : front = rear = -1
  - 공백 상태 : front = rear
  - 포화 상태 : rear = n - 1 (n : 배열의 크기 / n - 1 : 배열의 마지막 인덱스)



- 초기 공백 큐 생성
  - 크기 n인 1차원 배열 생성
  - front와 rear를 -1로 초기화



-----

- 큐 실습

1. 세 개의 데이터 1, 2, 3 을 차례로 큐에 삽입하고

2.  큐에서 세 개의 데이터를 차래로 꺼내서 출력한다.

   : 1, 2, 3 이 출력 되어야 함.



```python
Q = [0]*10

front, rear = -1, -1

def enQueue(item):
    #rear를 글로벌하게 쓰기 위해서... 
    global rear
    #만약 꽉 찼으면, item을 더할 수 없다. 그래서 꽉 찼다는 표시를 해보면,, 꽉 참 : rear = len(Q)-1
    if rear == len(Q) - 1:
        print('Queue full')
    #꽉차지 않았으면, rear를 +1 해주고, 그 rear 인덱스에 해당하는 value를 item으로 바꿔 줌
    else:
        rear += 1
        Q[rear] = item
    
def deQueue():       #어차피 가장 첫번째 꺼를 반환하는 것이기 때문에 ()안에 아무것도 없어도 된다.
    global front    #여기서는 front가 중요
    #queue 안에 아무것도 없으면 안된다.
    if front == rear:
        print('Queue empty')
    else:
        front += 1
        return Q[front]
    

#위의 enQueue 는 넣는 함수 / deQueue는 먼저 들어간 것을 반환하고 Q에서 삭제하는 함수
#이번에는 앞에서부터 삭제하지 않고 반환하는 함수.

def Qpeek():
    if front == rear:
        print('Queue empty')
    else:
        return Q[front + 1]
    #앞에서는 front = front + 1을 해줘서 그냥 front를 바꿨었는데
    #이번에는 입력값을 그냥 front+1을 줘버림으로써 Queue가 변하지 않는다.
```

```python

```



















