# 0902_정리

### Queue

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
  - 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조



- 앞에서 한 것들과는 다르게, **선입선출구조(FIFO : First In First Out)**

  - 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.

  

### 큐의 사용을 위해 필요한 주요 연산

1. enqueue(item) : 큐의 뒤쪽에 원소를 삽입하는 연산
2. dequeue : 큐의 앞쪽에서 원소를 삭제하고 반환하는 연산
3. createQueue : 공백 상태의 큐를 생성하는 연산
4. isEmpty : 큐가 공백상태인지를 확인하는 연산
5. isFull : 큐가 포화상태인지를 확인하는 연산
6. Qpeek : 큐의 앞쪽에서 원소를 삭제없이 반환하는 연산



- 머리(Front) : 저장된 원소 중 첫 번째 원소
- 꼬리(Rear) : 저장된 원소 중 마지막 원소



### 선형큐

- 1차원 배열을 이용한 큐
  - 큐의 크기 = 배열의 크기
  - front : 저장된 첫 번째 원소의 인덱스
  - rear : 저장된 마지막 원소의 인덱스
- 상태 표현
  - 초기 상태  : front = rear = -1
  - 공백 상태 : front = rear
  - 포화 상태 : rear = n - 1 (n : 배열의 크기 / n - 1 : 배열의 마지막 인덱스)



- 초기 공백 큐 생성
  - 크기 n인 1차원 배열 생성
  - front와 rear를 -1로 초기화



-----

- 큐 실습

1. 세 개의 데이터 1, 2, 3 을 차례로 큐에 삽입하고

2.  큐에서 세 개의 데이터를 차래로 꺼내서 출력한다.

   : 1, 2, 3 이 출력 되어야 함.



```python
Q = [0]*10

front, rear = -1, -1

def enQueue(item):
    #rear를 글로벌하게 쓰기 위해서... 
    global rear
    #만약 꽉 찼으면, item을 더할 수 없다. 그래서 꽉 찼다는 표시를 해보면,, 꽉 참 : rear = len(Q)-1
    if rear == len(Q) - 1:
        print('Queue full')
    #꽉차지 않았으면, rear를 +1 해주고, 그 rear 인덱스에 해당하는 value를 item으로 바꿔 줌
    else:
        rear += 1
        Q[rear] = item
    
def deQueue():       #어차피 가장 첫번째 꺼를 반환하는 것이기 때문에 ()안에 아무것도 없어도 된다.
    global front    #여기서는 front가 중요
    #queue 안에 아무것도 없으면 안된다.
    if front == rear:
        print('Queue empty')
    else:
        front += 1
        return Q[front]
    

#위의 enQueue 는 넣는 함수 / deQueue는 먼저 들어간 것을 반환하고 Q에서 삭제하는 함수
#이번에는 앞에서부터 삭제하지 않고 반환하는 함수.

def Qpeek():
    if front == rear:
        print('Queue empty')
    else:
        return Q[front + 1]
    #앞에서는 front = front + 1을 해줘서 그냥 front를 바꿨었는데
    #이번에는 입력값을 그냥 front+1을 줘버림으로써 Queue가 변하지 않는다.
```

```python
# 이 상태에서

enQueue(1)
enQueue(2)
enQueue(3)
을 해주면 Q = [1, 2, 3, 0, 0, 0, 0, 0, 0, 0] 이 된다.

이 때, Qpeek()을 해주면, #--> 1 이 리턴된다.

그리고, deQueue()를 세 번 해주면 각각, 
1
2
3
이 리턴되고 한 번 더 deQueue() 를 해보면 'Queue empty' 가 출력된다.
여기서도 또, Qpeek()을 해보면 'Queue empty'가 출력된다.
왜냐면, front가 rear과 같은 값이기 때문에 ...

사실 Q는 변하지 않는다. 계속 [1, 2, 3, 0, 0, ...] 이다.
```



----

# 우선순위 큐 (Priority Queue)

- 우선순위 큐의 특성
  - 우선순위를 가진 항목들을 저장하는 큐
  - FIFO 의 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다.



- 우선순위 큐의 구현
  - 배열을 이용한 우선순위 큐
  - 리스트를 이용한 우선순위 큐



- 배열을 이용하여 우선순위 큐 구현

  - 배열을 이용하여 자료 저장
  - 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
  - 가장 앞에 최고 우선순위의 원소가 위치하게 됨

  --->>> 그러나,,,,,, 이 방법은 **소모되는 시간이나 낭비되는 메모리가 크다.!!!!!!!**

































